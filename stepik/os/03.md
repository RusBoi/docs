
# Планирование и многозадачность

### Потоки исполнения и многопоточность

Поток исполнения - код и его контекст, где код это набор команд и регистр **RIP**. Контекст включает в себя значения регистров и память.

Поток - работает в контексте (адресном пространстве) некоторого процесса. Процесс содержит как минимум 1 поток. 

Каждый поток имеет свой собственный стек (место в памяти, на которое указывает **SP**). Несколько потоков могут работать *одновременно*. 

### Переключение потоков

Для переключения между потоками надо:

1. сохранить контекст исполняемого потока
2. восстановить контекст потока, на которых хотим переключиться

Сигнатура функции переключения указателей в C
```c++
void switch_threads(void **prev, void *next);
```
* `**prev` - по завершению функции будет указывать на место в памяти, где находится указатель на контекст потока, с которого мы переключились
* `*next` - указатель на контекст потока, на который мы переключаемся

Ассемблерный код
```
	.text
	.code64
	.global __switch_threads

__switch_threads:
	// сохраняем контекст потока, с которого переключаемся
	pushq %rbx
	pushq %rbp
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushfq    // пушим %rflags  на стек
	
	// %rdi - первый аргумент функции switch_threads
	movq %rsp, (%rdi)
	// %rsi - второй аргумент функции switch_threads
	movq %rsi, %rsp
	
	// восстанавливаем контекст потока, на который переключились
	popfq
	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbp
	popq %rbx

	retq  // т.к. %rsp поменялся, то тут мы со стека достанем совершенно другой адрес, нежели тот, что вызвал функцию __switch_threads
```

Нетрудно заметить, что мы сохранили на стек не все регистры общего назначения. Сохранить остальные регистры - обязанность функции, которая вызвала смену контекста. 

<img src="https://i.imgur.com/Jw7HXwy.png" height=250>

Для создания нового потока нужно:

* выделить участок памяти под стек этого потока
* на этот стек сохранить какой-то начальный контекст и указатель на него

Начальный контекст можно представить в виде ледующей структуры. Обрати внимание на порядок атрибутов

<img src="https://i.imgur.com/sAe9YaL.png" height=150>

### Планирование и многозадачность

Существует два подхода:

* **кооперативная многозадачность** - поток должен сам вызвать функцию переключения
* **вытесняющая многозадачность** - ОС вытесняет поток с CPU силой

**Прерывание** - некое событие, которое заставляет приостановить выполнение текущего потока и вызвать обработчик прерывания.

При этом обработчик прерывания будет выполняться в контексте прерванного потока. Поэтому в обработчике можно вызвать `switch_threads`. Как раз таки на этом и строется принцип работы вытесняющей многозадачности.

<img src="https://i.imgur.com/l1oM0H2.png" height=300>

Кто же бросает прерывания?

Таймер - устройство (hardware), позволяющее генерировать прерывание с заданной переодичностью.

* PIT - Programmable Interval Timer (старый)
* HPET - High Precision Event Timer (новый)
* Local APIC Timer - таймер на контроллерах прерываний

Пользовательским приложениям нельзя обрабатывать прерывания напрямую. Поэтому вместо прерываний используются сигналы (`SIG...`) в Unix подобных системах.


### Планирование и критерии планирования

**Планировщик** - компонент ОС, который определяет на какой поток переключаться и когда переключаться.

Простое планирование:

* все задачи известны заранее
* известна продолжительность каждой из задач
* задачи работают без переключений (`switch_threads` не вызывается в принципе)

Планировщику надо определить только порядок. Казалось бы, для ОС не важен порядок так как сумма затраченного времени не поменяется.

Но если в системе есть разные польователи с соответствующими пользовательскими задачами, то это не так очевидно. Введем следующую метрику, **среднее время ожидания** - время, которое пользователь ждет до завершения своей задачи. Порядок уже имеет значение. Надо просто отсортировать по времени исполнения.

Но естественно, обычно процессор не знает времени исполнения задач. Некоторые задачи взаимодействуют с внешними устройствами или ждут каких-то других событий (IO операции). 

* работа с HDD
* ввод от пользователя
* взаимодействие с сокетом

**Утилизаций CPU**  - сколько времени процессор провел в ожидании чего-то. 

* **IO-bounded** задача - много работы с I/O, мало вычислений (текстовый редактор, прикладные приложения с вводом пользователя)
* **CPU-bounded** задачи - много вычислений, но мало работы с I/O (компиляция программ, научные вычисления)

### Реалистичное планирование

`Round Robin` - выдает потокам квант времени по очереди. Достаточно прост и справедлив (время ожидания потока ограничено).

* поток, отработавший свой квант времени и не отдавший управление добровольно, встает в конец очереди
* новый поток встает в конец очереди
* потоки, дождавшиеся завершения IO, встают в конец очереди

>Планировщик работает в привилегированном режиме и может делать все что угодно

Недостаток `Round Robin` в том, что для IO-bounded задач время ожидания в очереди больше чем у других задач.

Чем больше квант времени, тем
* тем меньше доля времени на переключение
* тем больше время отклика

(и наоборот). 

#### Windows

Потокам назначен приоритет (всего 32). Одинаковый приоритет - ипользуется `Round Robin`. Приоритеты потоков - это само по себе не совсем честно, поэтому используются некоторые ивристики для избежания плохих ситуаций.

`Priority Boost` - помогает избегать голодания потоков посредством увеличения приоритета этих потоков. У потоков, связанных с  UI и IO, приоритет тоже повышен.

#### Linux

`CFS` (Comletely Fair Scheduler) - честный планировщик.

Для каждого потока поддерживается мера **виртуальное время** - сколько этот поток исполнялся на CPU. Соответственно, на выполнение выбирается тот поток, у кого это время минимально. 

>Конечно же в реальной реализации ядро ОС борется с ситуацией, когда какой-то поток сильно отстал по времени и ему надо выдасть кучу времени, пока остальные будут ждать