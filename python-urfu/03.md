# 3 - Базовые структуры данных: tuple, list, set, frozenset, dict
Для типов, которые содержат некую последовательность объектов, в питоне поддерживаются следующие операции:

- `x in s`
- `x not in s`
- `s[i]`
- `s[i:j]`
- `s[i:j:k]`
- `s + t`
- `s * n`,  `n * s`
- `len(s)`
- `max(s)`, `min(s)`
- `.index(x, [start [, end]])` - возвращает положение первого элемента со значением x
- `.count(x)` - возвращает количество элементов со значением x

Последовательности одного и того же типа также поддерживают операторы сравнения (сравниваются лексиграфически)

**Imutable** типы  дополнительно подерживают `hash()`

**Mutable** дополнительно поддерживают:

- `s[i] = val`
- `s[i:j] = val`
- `s[i:j:k] = val`
- `del s[i:j]` что равностильно `s[i:j] = []`
- `s.append(x)`
- `s.clear()`
- `s.copy()` - возвращает shallow copy
- `s.extend(t)` что равносильно `s += t`
- `s *= n`
- `s.insert(i, x)`
- `s.pop([index])`
- `s.remove(x)` - убирает первое вхождение элемента (или кидает `ValueError` при отсутствии)
- `s.reverse()`

## List (iterable, mutable)
Способы задачи:
```python
    l1 = [1, 2]
    l2 = list()
    l3 = list(range(10))
```
**List comprehension** 
```python
[x**2 for x in range(10)]
[(x,y) for x in [1,2,3] for y in [3,1,4] if x != y]
```
Уникальные методы:
- `.sort([key=None, reverse=None])` - где, `key` это функция, которая выбирает элемент для сравнения

## Tuple (iterable, immutable, hashable)
Меньший размер по сравнению со спиком.
Способы задачи:
```python
t1 = tuple()
t2 = tuple([1, 2, 3])
t3 = 1, 2, 3
t4 = 's',
```
Прикольный синтаксис: `a,b = b,a`

## Dict (iterable(ключи), mutable)
Способы задачи:
```python
d1 = {}
d2 = dict.fromkeys(['a', 'b'], 1)  # {'a' : 1, 'b' : 1}
d3 = dict('one'=1, 'two'=2)
```
**Dictionary comprehension**
```python
d3 = {a: a ** 2 for a in range(10)}
```
Уникальные методы:
- `.get(key[, default])`
- `.items()` - ключ-значение
- `.keys()`
- `.pop(key[, default])`
- `.popitem()` - удаляет и возвращает пару. Если словарь пуст, бросает исключение `KeyError`.
- `.setdefault(key[, default])` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ с значением default (по умолчанию None).
- `.update([other])` - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются.
- `.values()`

## Set (iterable, mutable)
Способы задачи:
```python
s1 = set()
s2 = set({'b' : 2, 'a' : 1})  # {'b', 'a'}
s3 = {1, 2, 3)
```
Может содержать только hashable объекты

Уникальные методы:
* `s <= t` - s подмножество t
* `s >= t` - t подмножество s
* `s | t` - объединение
* `s & t` - пересичение
* `s - t` - разность
* `s ^ t` - симметричная разность
* `.add(x)` - добавляет элемент к множеству.
* `.discard(x)` - удалить элемент если есть
* `.isdisjoint(x)` - истина если x и мн-во не имеют общих элементов
* `.issubset(s)` - ялвяется ли под-вом x
* `.issuperset()`
* `.pop()` - возращает и удаляет случайный элемент из мн-ва
* `.remove(x)` - удалить элемент из мн-ва (если нет такого эдемента, то KeyError)
* `.update(x)` - добавляет любой **iterable** объект.

## Frozenset (iterable, immutable)
Способы задачи эквивалентны `set`. Может содержать только hashable объекты

Уникальные методы
* поддерживает все методы множества, которые не меняют его

Можно проводить все алгебраические операции как со множествами:
* `frozenset` и `set` -> `set`
* `frozenset` и `frozenset` -> `frozenset`

