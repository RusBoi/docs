
# 12 - Функции как объекты. Декораторы


Функции - тоже объекты (как и все в Python). Функции можно передавать в качестве параметра, присваивать переменным и т.п. Также можно определять функции внутри других функций (дескрипторы)

* `filter(func, iterable)`
* `map(func, iterable)`

**Lambda-функции**
```python
f = lambda (x, y): x + y
```
Полезные атрибуты функций:
* `__name__` - имя функций. У анонимных: `<lambda>`
* `__doc__` - строка документации, по дефолту пустая
* `__module__` - название модуля, в котором функция была определена. `"__main__"` - если была определена здесь же

Функции объявляют, чтобы:
1. избежать дублирования кода
2. выделить логические блоки кода для повторного использования
3. улучшить читаемость кода
4. повысить управляемость кода (удобно для нахождения ошибок)


**Декораторы** - это своеобразные "обертки" над другими функциями, которые могут изменять поведения этих других функций без изменения их кода

> Декораторы - это функции, которые на вход принимают функцию (func1) и возвращают функцию (func2), которая изменяет работу func1

```python
def logging(func):
    def local_func(*args, **kwargs):
	    print(func.__name__)
	    return func(*args, **kwargs)
	local_func.__name__ = func.__name__
	local_func.__doc__= func.__doc__
	return local_func

@logging
def boo(a, b, c=1):
    print(a + b + c)
```

В данном примере `@logging` эквивалентно `boo = logging(boo)`

```python
def dec(a):
    def loc_decorator(func):
        def loc_func(*args, **kwargs):
            print(args, kwargs)
            print(a)
            return func(*args, **kwargs)
        return loc_func
    return loc_decorator

@dec('lol')
def boo(a, b):
    print('boo')
```
Или `boo = dec('lol')(boo)`

**Порядок следования декораторов важен**

```python
@dec_2
@dec_1
def bar():
    pass

@dec_1
@dec_2
def foo():
    pass
```

Часто вместе с функцией требуется протащить ее имя и докстринг. В этом нам поможет `functools.wraps`
```python
import functools

def logging(func):
    @functools.wraps(func)
    def local_func(*args, **kwargs):
        print(func.__name__)
        return func(*args, **kwargs)
    return local_func

@logging
def bar(text):
    print(text)
```
На практике очень часто используются декораторы:
* `@property` - для создания property у класса
* `@staticmethod` - делает метод статическим
* `@classmethod`

*P.S. На самом деле `@staticmethod` и `@classmethod` - это комбинация использования декораторов и дескрипторов*

Использование свойств
```python
class A:
    def __init__(self, r):
		self._r = r
        
    @propety
    def r(self):
		return self._r
    
    @r.setter
    def r(self, r):
		if r < 0:
		    raise ValueError
        else:
	        self._r = r
```
Примерная реализация `@staticmethod`

```python
class StaticMethod:  # так называемый протокол дескриптора     
    def __init__(self, func):
        self.__func__ = func

    def __get__(self, obj, type=None):
            return self.__func__

def staticmethod(func):  # сам декоратор
    return StaticMethod(func)

class A:
    @staticmethod
    def foo(a):
        print(a)

# То есть в функцию, вместо self, искусственно подбрасывается экземпляр класса StaticMethod
A().a(1)  # 1
A.a(1)  # 1
```
`functools` - библиотека с декораторами
