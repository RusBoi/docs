# 14 - Обработка исключений

import sys
import traceback

## Обработка исключения
```python
try1_stmt ::=
    try : suite
    (except : [expression [as target]] : suite)+
    [else : suite]  # если не было исключений
    [finally : suite]  # выполняется всегда в конце
try2_stmt ::=
    try : suite
    finally : suite
```
## Генерация исключения
```python
raise_stmt ::= raise [expression [from expression]]
```
Можно кидать исключения в обработчике
```python
try:
	raise Exception
except:
	raise ValueError
```
```python
Exception: <...>
During handling of the above exception, another exception occurred:
ValueError: <...>
```

Как видно из синтаксиса, можно не указывать исключение: тогда будет прошено предыдущие исключение (если такого не было, то `RuntimeError`
```python
try:
    raise ValueError
except ValueError as e:
	<...>
    raise 
```
```python
ValueError: <...>
```

```python
except ValueError as e:
    print('except ValueEror')
except:
    print('except')
    # ветка, которая охватит все оставшиеся исключения
else:
    print('else')
finally:
    print('finally')
```
При попытке вызвать исключение в обработчике, оно будет вызвано **после** исполнения блока `finally`


`sys.exc_info()` - хранит информацию об последнем вызванном исключении, пойманным блоком except. Возвращает `(type, value, traceback)`

`traceback.print_exception((type, value, tb))` - печатает инфу по исключению

`tracebcak.print_exc()` то же самое, что `traceback.print_exception(sys.exc_info())`
```python
def f1():
    f2()

def f2():
    f3()

def f3():
    raise ValueError
```
Исключение всплывает вверх по стеку вызовов.

В обрабатывающих ветках можно указывать большо одного исключения
```python
try:
    pass
except (ValueError, MyError, RuntimeError):
    pass
```

Блок `finally` выполняется всегда, когда интерпретатор покидает оператор `try`, независимо — были исключения или нет. Если в блоке `try` появилось исключение, которое не было обработано в блоке `except` (или появилось в самих блоках `except` или `else`) — оно порождается заново после выполнения блока `finally`.

Полезные атрибуты класса `Exception`:
* `__cause__` - что послужило исключением
* `__context__` - контекст из которого было вызвано исключение
* `__supress_context__` - флаг подавления вывода `__context__`
* `args` - аргументы

___
Конструкция
```python
raise <exception1> from <exception2>
```
позволяет пояснять программисту, что послужило причиной вызова первого исключения. Для этого меняется значение атрибута `__cause__`.
При этом пишется следующее
```python
<exception1_info>: 

The above exception was the direct cause of the following exception:

<exception2_info>
```

Если мы бросили исключение **в обработчике исключений**, то устанавливается поле `__context__`. Пишется слудующее
```python
<exception1_info>

During handling of the above exception, another exception occurred:

<exception2_info>
```

Если совместить 2 случая выше, то будет установлено только поле `__cause__` (влажок `__supress_context__` будет `True`). Поэтому чтобы избежать лишней инфы при кидании исключения в обработчике используют следующую конструкцию:
```python
try:
	...
except:
	raise <exception> from None
```


# 15. Создание собственных классов исключений. Иерархии исключений.

Создадим свое исключение
```python
class MyError(Exception):
    def __init__(self, message):
            self.message = message
        
    def __str__(self):
            return self.message

raise MyError('Lol')
```

# 16 - Устройство with
```python
with_stmt ::= with with_item (, with_item)* : suite,
где
with_item ::= expression [as target]
```

**Менеджер контекста** - объект, поддерживающий 2 метода:
* `__enter__()` - возвращает объект, результат операции
* `__exit__(exc_type, exc_value, exc_traceback)` - обрабатывает исключение. При успехе: `True`, иначе `False`

```python
mgr = (EXPR)
exit = mgr.__exit__
value = mgr.__enter__()
no_exc = True

try:
    try:
        VAR = value
        BLOCK
    except:
        no_exc = False
        if not exit(*sys.exc_info()):
            raise
finally:
    if no_exc:
        exit(None, None, None)
```
Равносильно следующей конструкции
```python
with EXPR as VAR:
    BLOCK
```
Следующие конструкции эквиваленты
```python
with A() as a:
    with B() as b:
        suite

with A() as a, B() as b:
    suite
```


# 17 - Модули, пакеты, import и его варианты

## Модули

Модуль - просто файл с расширением `.py`. Из себя он представляет объект с определенными аттрибутами к которым можно обращаться. Импортируется модуль через `import`, `as` - просто переименовывает ссылку на этот объект для того, чтобы можно было удобнее к нему обращатся (имя модуля не меняется). Граница между модулем и объектом тонка.

`sys.path` - содержит пути, в которых питон ищет модули

Интересные аттрибуты модулей:
* `__cached__` - скомпилированный байт-код версии исходного файла
* `__doc__` - докстринг как в функции
* `__file__` - абсолютный путь до файла
* `__name__` - имя модуля (файла). При запуске `"__main__"`
* `__parent__` - имя пакета, в котором находится данным модуль

___
```python
from <module> import <something>
```
 Ипортирует атрибуты из модуля в текущую область видимость. Сам модуль не импортируется

```python
from <module> import *
```
Импортируем из модуля все атрибуты, кроме скрытых (тех, что начинаются с `_`). Для изменения повидения данной операции юзай атрибут `__all__` (контролирует только `*`)

Процесс импортирования модуля:
1. найти, в каком файле расположен данный модуль.
	* Питон смотрит в кэш, не был ли модуль импортирован ранее
	* поискать встроенный модуль
	* смотрит в текущей папке
	* обращается к некоторому списку путей из `sys.path`, `$PYTHONPATH`
2. создать соответствующие имена переменных в текущем пространстве имен.

## Пакеты

Пакет это любая папка с модулями (можно и без) + `__init__.py`
```
test
├── bar.py
├── foo.py
├── __init__.py
└── main.py
```

```python
import test
```
Тут на самом деле импортируется (и запускаетя) модуль `__init__.py`
Остальные пакеты надо импортировать явно

```python
import test.foo
```
Ипортирует модуль `foo.py` а также `__init__.py` (если он еще не был импортирован)

Два вида импортирования:
* Абсолютный импорт - полность прописываем путь до **пакета**
* Относительный ипорт  - можно использовать `.`/`..` для указания путя **пакета**. `from .package1.package2.test import foo`

**Опять же, чтобы юзать относительный испорт необходимо, чтобы директория являлась пакетом**

Чтобы пакет был исполняемым надо добавить `__main__.py`

>Пакеты содержат в себе наборы модулей. Отличительная черта пакета - это некоторая директория, которая содержит файл `__init__.py`. В этом файле можно описать код, который будет инициализировать пакет. Инициализационный код выполняется только один раз при импортировании пакета (даже если из него импортируются разные модули).
 
Чтобы импортировать из одного модуля пакета другой модуль этого же пакета, надо указать не только имя импортируемого модуля, но и сначала имя самого пакета, так как поиск ведётся в текущей директории, а не в директории пакета.

Одни пакеты можно вкладывать в другие. 

Так же полезен модуль `importlib`

# 18 - Пространство имен, область видимости
**Пространство имен** - соответствие имени переменной и ссылки на объект, которая она хранит.

**Область видимости** - те участки кода, откуда будет доступен данный объект.

Пространства имён содержит:
1. пространство локальных имен
2. пространство имен окружающих функций, начиная от самой ближайшей по вложенности
3. пространство глобальных имен
4. пространство встроенных имен (например, built-in functions)

```python
c = 10
def f():
    global c # после этого под с будет пониматься глобальная переменная
    c = 11
    print(c)
    
print(c)  # 10
f()  # 11
print(c)  # 11
```
По завершению работы функции её пространство имен удаляется
```python
a = 1

def f():
    a = 2    
    def g():
		print(a)  # 2 
        nonlocal a
        a = 3
        print(a)  # 3
    g()
    print(a)  # 3

f()
print(a)  # 1
```
`nonlocal` смотрит на уровень вложенности выше, но вылезает в пространство глобальных переменных (если некуда лезть, то `SyntaxError`)

Внутри if-ов и циклов не создается свое пространство имен

* `globals()` - словарь глобальных переменных
* `locals()` - словарь локальных переменных


# 19 - Метод `__del__`. Удаление объектов при помощи подсчета ссылок

Метод `__del__` предназначен для удаления объектов из памяти. Он вызывается, когда на объект никто не ссылается.

sys.getrefcount(obj) - метод, возвращающий кол-во ссылок на переданный объект + 1 (из-за внутренней реализации)

Счетчик ссылок и сборщик мусора работают сообща :) Сборщик мусора доступен в модуле gc. 

ВАЖНО понимать, что оператор del не имеет никакого отношения непосредственно к объектам. Он всего лишь удаляет переменные из текущего пространства имен.

a = '123'
b = a
del a
print(b)  # 123

Циклические ссылки:

class Element:
    def __init__(self, data, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next
        
    def __del__(self):
        print('deleting', self.data)

head = Element(1)
tail = Element(2)
head.prev = tail
tail.next = head

del head
del tail

Данные объекты будут удалены только по завершению работы скрипта.

Слабые ссылки (weak reference)
Отличаются от обычных ссылок тем, что не увеличивают счетчик ссылок объекта, на который ссылаются. Как следствие: не оказывает влияния на работу garbage collector’а. Можно использовать для избежания циклических ссылок.

Для создания ссылки на объект используй метод weakref.proxy(obj)
КТО-НИБУДЬ МОЖЕТ ОБЪЯСНИТЬ ЭТОТ ПРИМЕР И КАК ОН РАБОТАЕТ:

import weakref
import gc

class MyObject(object):
    def my_method(self):
        print('my_method was called!')

obj = MyObject()
r = weakref.ref(obj)

gc.collect()
assert r() is obj  #r() allows you to access the object referenced: it's there.

obj = 1  # Let's change what obj references to
gc.collect()
assert r() is None  #There is no object left: it was gc'ed.

20 - Работа с файлами
методы:
open(file, mode='r', encoding=None)
file - строка-путь до файла
mode:
    'r' open for reading (default)
    'w' open for writing, truncating the file first
    'x' open for exclusive creation, failing if the file already exists
    'a' open for writing, appending to the end of the file if it exists
    'b' binary mode
    't' text mode (default)
    '+' open a disk file for updating (reading and writing) 
f.read() - можно указать кол-во символ для считывания
f.seek(i) - перейти к i-ому символу
f.close()  - закрыть файл(вернуть ОС ее ресурсы)
f.write(b’...’) - записывает байты в файл, возвращает кол-во записанных файлов

Исключения при работе с файлами:
FileNotFoundError - пытаться открыть несуществующий файл
IsADirectoryError - открыть директорию вместе файла
PermissionError - пытаться записать в файл, который не поддерживает запись


21 - Создание потоков, модуль threading

import threading
import time

def func():
    for _ in range(10):
        time.sleep(0.001) # уведичиваем вероятность то, что другой тред начнет свою работу
        print('hello from', threading.current_thread().name)

for _ in range(10):
    t = threading.Thread(target=func)
    t.start()


class Worker(threading.Thread):
    def run(self):
        for _ in range(10):
            time.sleep(0.001) # уведичиваем вероятность то, что другой тред начнет свою работу
            print('hello from', threading.current_thread().name)

for _ in range(10):
    t = Worker()
    t.start()

count = 0
lock = threading.Lock()
def inc():
    global count
    with lock:
        k = count
        time.sleep(0.001)
        count = k + 1
pool = []    
for _ in range(1000):
    t = threading.Thread(target=inc)
    t.start()
    pool.append(t)
for t in pool:
    t.join()  # ждем его завершения
print(count)




Deadlock

lock1 = threading.Lock()
lock2 = threading.Lock()

def good():
    with lock1:
            time.sleep(1)
        with lock2:
            print('good')

def bad():
    with lock2:
            with lock1:
                print('bad')

threading.Thread(target=good).start()
threading.Thread(target=bad).start()


Ожидание завершения:
    th.join() # блокирующий вызов

В мультипоточной программе доступ к объектам иногда нужно синхронизировать.
С этой точки зрения все объекты (переменные) разделяются на:
●     Неизменяемые. Если объект никто не меняет, то синхронизация доступа ему не нужна. К сожалению, таких не очень много.
●     Локальные. Если объект не виден остальным потокам, то доступ к нему синхронизировать тоже не требуется.
●     Разделяемые и изменяемые. Необходима синхронизация.

>>> lock.acquire() # захватить lock
>>> lock.release() # отпустить lock
22 - Способы создания процессов
Процесс - уже самостоятельная единица ОС и может происходить ядерное распараллеливание. Процесс имеет как минимум 1 поток (главный).
Процессы имеют разные области памяти. В том числе, можно запустить их на разных интерпретаторах python (например p2 и p3)
os.fork для Unix-подобных. Быстр.При вызове fork у процесса возникает его идентичная копия.  Возвращает идентификатор процесса (для родительского - его ребенка, а для дочернего- 0). По ним можно узнать в каком именно процессе мы сейчас находимся. Копирует все данные из одного процесса в другой. Могут возникнуть проблемы с процессобезопасностью. Для нормальной работы нужна синхронизация и взаимодействие между процессами. Взаимодействие может осуществляться с помощью file, signals,  pipe, socket, mmap.
subprocess - позволяет создать новый процесс и обмениваться с ним информацией по трубам / стандартным потокам ввода/вывода
cmd = "ping google.com"
p = subprocess.Popen(cmd, shell = True) 
Мы можем проверять статус потока (процесса, не?), а так же отправлять ему сигналы (а-ля завершись)
pid - идентификатор процесса.
3) multiprocessing.Process(target=foo) запуск нового процесса с исполняемой функцией
4) concurent.futures - позволяет удобно работать с процессами

