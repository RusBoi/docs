# 14 - Обработка исключений

import sys
import traceback

## Обработка исключения
```python
try1_stmt ::=
    try : suite
    (except : [expression [as target]] : suite)+
    [else : suite]  # если не было исключений
    [finally : suite]  # выполняется всегда в конце
try2_stmt ::=
    try : suite
    finally : suite
```
## Генерация исключения
```python
raise_stmt ::= raise [expression [from expression]]
```
Можно кидать исключения в обработчике
```python
try:
	raise Exception
except:
	raise ValueError
```
```python
Exception: <...>
During handling of the above exception, another exception occurred:
ValueError: <...>
```

Как видно из синтаксиса, можно не указывать исключение: тогда будет прошено предыдущие исключение (если такого не было, то `RuntimeError`
```python
try:
    raise ValueError
except ValueError as e:
	<...>
    raise 
```
```python
ValueError: <...>
```

```python
except ValueError as e:
    print('except ValueEror')
except:
    print('except')
    # ветка, которая охватит все оставшиеся исключения
else:
    print('else')
finally:
    print('finally')
```
При попытке вызвать исключение в обработчике, оно будет вызвано **после** исполнения блока `finally`


`sys.exc_info()` - хранит информацию об последнем вызванном исключении, пойманным блоком except. Возвращает `(type, value, traceback)`

`traceback.print_exception((type, value, tb))` - печатает инфу по исключению

`tracebcak.print_exc()` то же самое, что `traceback.print_exception(sys.exc_info())`
```python
def f1():
    f2()

def f2():
    f3()

def f3():
    raise ValueError
```
Исключение всплывает вверх по стеку вызовов.

В обрабатывающих ветках можно указывать большо одного исключения
```python
try:
    pass
except (ValueError, MyError, RuntimeError):
    pass
```

Блок `finally` выполняется всегда, когда интерпретатор покидает оператор `try`, независимо — были исключения или нет. Если в блоке `try` появилось исключение, которое не было обработано в блоке `except` (или появилось в самих блоках `except` или `else`) — оно порождается заново после выполнения блока `finally`.

Полезные атрибуты класса `Exception`:
* `__cause__` - что послужило исключением
* `__context__` - контекст из которого было вызвано исключение
* `__supress_context__` - флаг подавления вывода `__context__`
* `args` - аргументы

___
Конструкция
```python
raise <exception1> from <exception2>
```
позволяет пояснять программисту, что послужило причиной вызова первого исключения. Для этого меняется значение атрибута `__cause__`.
При этом пишется следующее
```python
<exception1_info>: 

The above exception was the direct cause of the following exception:

<exception2_info>
```

Если мы бросили исключение **в обработчике исключений**, то устанавливается поле `__context__`. Пишется слудующее
```python
<exception1_info>

During handling of the above exception, another exception occurred:

<exception2_info>
```

Если совместить 2 случая выше, то будет установлено только поле `__cause__` (влажок `__supress_context__` будет `True`). Поэтому чтобы избежать лишней инфы при кидании исключения в обработчике используют следующую конструкцию:
```python
try:
	...
except:
	raise <exception> from None
```


# 15. Создание собственных классов исключений. Иерархии исключений.

Создадим свое исключение
```python
class MyError(Exception):
    def __init__(self, message):
            self.message = message
        
    def __str__(self):
            return self.message

raise MyError('Lol')
```

# 16 - Устройство with
```python
with_stmt ::= with with_item (, with_item)* : suite,
где
with_item ::= expression [as target]
```

**Менеджер контекста** - объект, поддерживающий 2 метода:
* `__enter__()` - возвращает объект, результат операции
* `__exit__(exc_type, exc_value, exc_traceback)` - обрабатывает исключение. При успехе: `True`, иначе `False`

```python
mgr = (EXPR)
exit = mgr.__exit__
value = mgr.__enter__()
no_exc = True

try:
    try:
        VAR = value
        BLOCK
    except:
        no_exc = False
        if not exit(*sys.exc_info()):
            raise
finally:
    if no_exc:
        exit(None, None, None)
```
Равносильно следующей конструкции
```python
with EXPR as VAR:
    BLOCK
```
Следующие конструкции эквиваленты
```python
with A() as a:
    with B() as b:
        suite

with A() as a, B() as b:
    suite
```


# 17 - Модули, пакеты, import и его варианты

## Модули

Модуль - просто файл с расширением `.py`. Из себя он представляет объект с определенными аттрибутами к которым можно обращаться. Импортируется модуль через `import`, `as` - просто переименовывает ссылку на этот объект для того, чтобы можно было удобнее к нему обращатся (имя модуля не меняется). Граница между модулем и объектом тонка.

`sys.path` - содержит пути, в которых питон ищет модули

Интересные аттрибуты модулей:
* `__cached__` - скомпилированный байт-код версии исходного файла
* `__doc__` - докстринг как в функции
* `__file__` - абсолютный путь до файла
* `__name__` - имя модуля (файла). При запуске `"__main__"`
* `__parent__` - имя пакета, в котором находится данным модуль

___
```python
from <module> import <something>
```
 Ипортирует атрибуты из модуля в текущую область видимость. Сам модуль не импортируется

```python
from <module> import *
```
Импортируем из модуля все атрибуты, кроме скрытых (тех, что начинаются с `_`). Для изменения повидения данной операции юзай атрибут `__all__` (контролирует только `*`)

Процесс импортирования модуля:
1. найти, в каком файле расположен данный модуль.
	* Питон смотрит в кэш, не был ли модуль импортирован ранее
	* поискать встроенный модуль
	* смотрит в текущей папке
	* обращается к некоторому списку путей из `sys.path`, `$PYTHONPATH`
2. создать соответствующие имена переменных в текущем пространстве имен.

## Пакеты

Пакет это любая папка с модулями (можно и без) + `__init__.py`
```
test
├── bar.py
├── foo.py
├── __init__.py
└── main.py
```

```python
import test
```
Тут на самом деле импортируется (и запускаетя) модуль `__init__.py`
Остальные пакеты надо импортировать явно

```python
import test.foo
```
Ипортирует модуль `foo.py` а также `__init__.py` (если он еще не был импортирован)

Два вида импортирования:
* Абсолютный импорт - полность прописываем путь до **пакета**
* Относительный ипорт  - можно использовать `.`/`..` для указания путя **пакета**. `from .package1.package2.test import foo`

**Опять же, чтобы юзать относительный испорт необходимо, чтобы директория являлась пакетом**

Чтобы пакет был исполняемым надо добавить `__main__.py`

>Пакеты содержат в себе наборы модулей. Отличительная черта пакета - это некоторая директория, которая содержит файл `__init__.py`. В этом файле можно описать код, который будет инициализировать пакет. Инициализационный код выполняется только один раз при импортировании пакета (даже если из него импортируются разные модули).
 
Чтобы импортировать из одного модуля пакета другой модуль этого же пакета, надо указать не только имя импортируемого модуля, но и сначала имя самого пакета, так как поиск ведётся в текущей директории, а не в директории пакета.

Одни пакеты можно вкладывать в другие. 

Так же полезен модуль `importlib`

# 18 - Пространство имен, область видимости
**Пространство имен** - соответствие имени переменной и ссылки на объект, которая она хранит.

**Область видимости** - те участки кода, откуда будет доступен данный объект.

Пространства имён содержит:
1. пространство локальных имен
2. пространство имен окружающих функций, начиная от самой ближайшей по вложенности
3. пространство глобальных имен
4. пространство встроенных имен (например, built-in functions)

```python
c = 10
def f():
    global c # после этого под с будет пониматься глобальная переменная
    c = 11
    print(c)
    
print(c)  # 10
f()  # 11
print(c)  # 11
```
По завершению работы функции её пространство имен удаляется
```python
a = 1

def f():
    a = 2    
    def g():
		print(a)  # 2 
        nonlocal a
        a = 3
        print(a)  # 3
    g()
    print(a)  # 3

f()
print(a)  # 1
```
`nonlocal` смотрит на уровень вложенности выше, но вылезает в пространство глобальных переменных (если некуда лезть, то `SyntaxError`)

Внутри if-ов и циклов не создается свое пространство имен

* `globals()` - словарь глобальных переменных
* `locals()` - словарь локальных переменных


# 19 - Метод `__del__`. Удаление объектов при помощи подсчета ссылок

Метод `__del__` предназначен для удаления объектов из памяти. Он вызывается, когда на объект никто не ссылается.

`sys.getrefcount(obj)` - метод, возвращающий кол-во ссылок на переданный объект + 1 (из-за внутренней реализации)

Счетчик ссылок и сборщик мусора работают сообща. Сборщик мусора доступен в модуле `gc`. 

Важно понимать, что оператор `del` не имеет никакого отношения непосредственно к объектам. Он всего лишь удаляет переменные из текущего пространства имен (то есть удаляет ссылку на объект)

```python
a = '123'
b = a
del a
print(b)  # 123
```
**Циклические ссылки**
```python
class Element:
    def __init__(self, data, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next
        
    def __del__(self):
        print('deleting', self.data)

head = Element(1)
tail = Element(2)
head.prev = tail
tail.next = head

del head
del tail
```
Ни один объект не будет забран сборщиком, так как оба объекта ссылаются друг на друга (как минимум есть по одной сслыке на каждый объект). Данные объекты будут удалены только по завершению работы скрипта.

**Слабые ссылки (weak reference)**

Отличаются от обычных ссылок тем, что не увеличивают счетчик ссылок объекта, на который ссылаются. Как следствие: не оказывает влияния на работу сборщика мусора. Можно использовать для избежания циклических ссылок.

Для создания ссылки на объект используй метод `weakref.ref(obj)`
```python
import weakref
import gc


class MyObject(object):
    def my_method(self):
        print('my_method was called!')

obj = MyObject()
r = weakref.ref(obj)

gc.collect()
assert r() is obj
# r() позволяет обратиться к объекту на который ссылается

obj = 1
gc.collect()
assert r() is None  # Объект был удален сборщиком мусора
```
# 20 - Работа с файлами
Методы:
* `open(file, mode='r', encoding=None)`

	mode:
	* `r` на чтение
	* `w` на запись (с начала файла)
	* `x` исключение, если файл уже в каталоге
	* `a` на запись (дописать в конец)
	* `b` байты
	* `t` символы

* `f.read([n])` - можно указать кол-во символ для считывания
* `f.seek(i)` - перейти к i-ому символу
* `f.close()`  - закрыть файл
* `f.write(data)` - записывает данные в файл, возвращает кол-во записанных файлов

# 21 - Создание потоков, модуль threading
Пример работа с тредами
```python
import threading
import time

def func():
    for _ in range(10):
        time.sleep(0.001) # уведичиваем вероятность то, что другой тред начнет свою работу
        print('hello from ', threading.current_thread().name)

for _ in range(10):
    t = threading.Thread(target=func)
    t.start()
```
Залочим переменную. Это необходимо, так как прибавление еденицы не атомарная операция.
```python
count = 0
lock = threading.Lock()

def inc():
    global count
    with lock:
        k = count
        time.sleep(0.001)
        count = k + 1

pool = []    
for _ in range(1000):
    t = threading.Thread(target=inc)
    t.start()
    pool.append(t)
for t in pool:
    t.join()  # ждем его завершения
print(count)
```
Deadlock
```python
lock1 = threading.Lock()
lock2 = threading.Lock()

def good():
    with lock1:
        time.sleep(1)
        with lock2:
            print('good')

def bad():
    with lock2:
	    with lock1:
	        print('bad')

threading.Thread(target=good).start()
threading.Thread(target=bad).start()
```


В мультипоточной программе доступ к объектам иногда нужно синхронизировать. С этой точки зрения все объекты (переменные) разделяются на:
 * Неизменяемые. Если объект никто не меняет, то синхронизация доступа ему не нужна. К сожалению, таких не очень много.
* Локальные. Если объект не виден остальным потокам, то доступ к нему синхронизировать тоже не требуется.
* Разделяемые и изменяемые. Необходима синхронизация.

`lock.acquire()` - захватить lock
`lock.release()` - отпустить lock

# 22 - Способы создания процессов

**Процесс** - уже самостоятельная единица ОС и может происходить ядерное распараллеливание. Процесс имеет как минимум 1 поток (главный). Процессы имеют разные области памяти. 

Для нормальной работы нужна синхронизация и взаимодействие между процессами. Взаимодействие может осуществляться с помощью `file`, `signals` (список сигналов - `kill -l`),  `pipe`, `socket`, `mmap`.

Способы создания новых процессов:

1. В Unix-подобных ОС используется `fork()` (`os.fork`). Данный способ достаточно быстрый. При вызове `fork()` у процесса возникает его идентичная копия. Возвращает `pid` процесса (для родительского - `pid` ребенка, а для дочернего - 0). По ним можно узнать в каком именно процессе мы сейчас находимся. Копирует все данные из одного процесса в другой. Могут возникнуть проблемы с процессобезопасностью.



2. `subprocess` - позволяет создать новый процесс и обмениваться с ним информацией по трубам, стандартным потокам ввода-вывода
	```python
	cmd = 'ping google.com'
	p = subprocess.Popen(cmd, shell = True) 
	```
3. `multiprocessing.Process(target=foo)` запуск нового процесса с исполняемой функцией
4. `concurent.futures` - модуль для удобной работы как с потоками, так и с процессами

