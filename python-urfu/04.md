
## 4 - Строки: bytes, bytearray, str. Кодировки
`bytes.encode() -> str`

`str.decode() -> bytes`


## Str (iterable, immutable, hashable)

Содержит упорядоченную последовательность символов, каждый из которых по отдельности тоже строка. Может использоваться slice.
Сырые строки(`r'sample'`) - подавляют экранирование.

 * `.find(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или -1
 * `.rfind(str, [start],[end])` - поиск подстроки в строке. Возвращает номер последнего вхождения или -1
 * `.index(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или бросает ValueError
 * `.rindex(str, [start],[end]) `- поиск подстроки в строке. Возвращает номер последнего вхождения или бросает ValueError
 * `.isdigit()` - только цифры
 * `.isalpha()` - только буквы
 * `.isalnum()` - только цифры + буквы
 * `.islower()` - нижний регистр
 * `.isupper()` - верхний регистр
 * `.isspace()` - пробельные символы
 * `.istitle()` - с заглавной буквы
 * `.upper()`
 * `.lower()`
 * `.capitalize()`
 * `.swapcase()`
 * `.title()`
 * `.expandtabs()` - все `\t` в пробелы
 * `.startswith(str)`
 * `.endswith(str)`
 * `.count(sub[, start[, end]])` - выводит кол-во вхождений построки в строку. Учитываются только не перекрывающиеся вхождения
 * `.replace(old, new[, count])` - замена старой подстроки на новую `count` кол-во раз. Возвращает копию!
 * `.split(sep=None, maxsplit=-1)` - разбиение строки по разделителю (разделитель может быть строкой)
 * `.join(iterable)`
 * `.lstrip()`
 * `.strp()`
 * `.rstrip()`

`ord`; `chr`

* `.zfill(width)` - дописывает в начало строки 0, чтобы длина строки достикла `width`. Если на первом месте стоит +/-, то нули дописываются посл этого знака.

`.encode(encoding='urf-8', errors='strict')`
`.format(*args, **kwargs)`

## Bytes (iterable, immutable, hashable)

Элементы - байты, s[i] - выводит код ascii сивмвола. Является последовательностью чисел в диапазоне `[0..255]`

Для того, чтобы задать байтовую строку используется следующие правило:
* `[0..127]` показываются как литералы из ASCII таблицы. Все, кроме нечитаемых
* `[128..255]` показывается как escape-последовательность
	* `\x.. - hex[0..F]`
	* `\... - oct [0..7])`

Способы задачи:
```python
b1 = bytes([1, 2, 90, 255])
b2 = b'\xff\xf9\567'
```
Если допущена ошибка в escape-последовательности при задаче hex, то `ValueError`; в oct - просто игнорируется

## Bytearray (iterable, mutable)
Массив байт. Отличается от bytes только изменяемостью. Создаются только через конструктор

Методы соответствуют методам у строк + некоторые методы из списка. Единственный уникальный метод: `.decode(encoding='urf-8', errors='strict')`

