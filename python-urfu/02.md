## 2 - Функции, аргументы функции
Функции в Питоне тоже являются объектами, у которых определен метод `__call__`, который вызывается при написании круглых скобок. Функции вегда что-то возвращает. Даже если не указан `return` в коде (в этом случае возвращается None). 
Функция - **callable** объект

Типы аргументов:

- позиционные (определяются по их позиции в скобках)
- именные (определяются по имени аргумента)

Естественно, их можно комбинировать.

Дана функция
```python
def foo(a, b, c):
	pass
```

Ошибки:

- `foo(1, a=3, b=2)` - параметр `а` определяется несколько раз
- `foo(b=3, a=2, 2)` - позиционные аргументы должны идти всегда перед именными


___
#### Распаковка
Пусть
```python
a = [1, 2, 3]
a1 = [2, 3]
d = {'c' : 3, 'b' : 12, 'a' : 1}
d1 = {'a':1, 'b':2}
```

`f(*a)` - позиционная распаковка из списка
`f(**d)` - именная распаковка из словаря

Распаковку можно комбинировать с другими параметрами:

* `f(1, *a1)`
* `f(c=1, **d1)` 

Частые ошибки:

* `f(*a1, b=2)` - `b` определено несколько раза
* `f(**d, 1)` - нельзя ставить позиционный аргумент после именной распаковки
* `f(**{a:1}, [2, 3])` - нельзя делать именную распаковку перед позиционной

#### Упаковка
Упаковать аргументы функции обратно в список
```python
def foo(*args):
    pass 
```

Упаковать аргументы функции обратно в словарь
```python
def foo(**args):
	pass
```
Можно смешивать способы
```python
def foo(*args, c=10):
	pass

def bar(*args, **kwargs):
	pass
```
Ошибки:
```python
def f(**args, c)
```
```python
def f(**args, c=10)
```
**После именной упаковки ничего не должно идти!**

___
Можно прописать значения по умолчанию для параметров функции. 
```python
def g(a, b=2, c=3):
	pass

```
Ошибкой будет являться следующий код (так как недефолтный аргумент идет после дефолтного)
```python
def f(a, b=2, c):
	pass
``` 

#### Анонимные функции

```python
f = lambda x: x + 1
```
#### Замыкание
**Замыкание** - это процедура вместе с привязанной к ней совокупностью данных (в противовес объектам в объектном программировании, как: "данные вместе с привязанным к ним совокупностью процедур" ).

Смысл замыкания состоит в том, что определение функции "замораживает" окружающий её контекст на момент определения.
```python
n = 10
def foo(a=n):
	print(a)

foo() # 10
n = 2
foo() # 10
```

С лямбдами это работает совершенно по другому
```python
n = 10
foo = lambda x: n * x
foo(2) # 20
n = 2
foo(2) # 4
```

