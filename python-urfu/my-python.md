<a id="markdown-содержание" name="содержание"></a>
# Содержание 

<!-- TOC -->

- [Содержание](#содержание)
- [1 - Объекты, переменные](#1---объекты-переменные)
- [2 - Функции, аргументы функции](#2---функции-аргументы-функции)
- [3 - Базовые структуры данных: tuple, list, set, frozenset, dict](#3---базовые-структуры-данных-tuple-list-set-frozenset-dict)
- [4 - Строки: bytes, bytearray, str. Кодировки](#4---строки-bytes-bytearray-str-кодировки)
- [5 - Классы. Методы `__new__`, `__init__`. Переопределение арифметических операций над объектами](#5---классы-методы-__new__-__init__-переопределение-арифметических-операций-над-объектами)
- [6 - Итератор. Устройство цикла for](#6---итератор-устройство-цикла-for)
- [7 - Генераторы. Генераторные выражения](#7---генераторы-генераторные-выражения)
- [8 - Генераторные функции](#8---генераторные-функции)
- [9 - list, set, dict comprehensions](#9---list-set-dict-comprehensions)
- [10 - Функции как объекты. Декораторы](#10---функции-как-объекты-декораторы)
- [11 - Наследование в классах](#11---наследование-в-классах)
- [12 - Обработка исключений](#12---обработка-исключений)
- [13 - Создание собственных классов исключений. Иерархии исключений.](#13---создание-собственных-классов-исключений-иерархии-исключений)
- [14 - Устройство with](#14---устройство-with)
- [15 - Модули, пакеты, import и его варианты](#15---модули-пакеты-import-и-его-варианты)
- [16 - Пространство имен, область видимости](#16---пространство-имен-область-видимости)
- [17 - Метод `__del__`. Удаление объектов при помощи подсчета ссылок](#17---метод-__del__-удаление-объектов-при-помощи-подсчета-ссылок)
- [18 - Работа с файлами](#18---работа-с-файлами)
- [19 - Создание потоков, модуль threading](#19---создание-потоков-модуль-threading)
- [20 - Способы создания процессов](#20---способы-создания-процессов)

<!-- /TOC -->

<a id="markdown-1---объекты-переменные" name="1---объекты-переменные"></a>
# 1 - Объекты, переменные
Все данные в питоне это объекты. Каждый объект имеет:

- Идентификатор (`id()`)
- Тип (`type()`)
- Значение

Объект делятся на:

- mutable (изменяемые)
- immutable (неизменяемые) 

Неизменяемые: 

1. `frozenset`
2. `tuple`
3. `str`

Изменяемые:

1. `int`
2. `list`
3. `dict`
4. `set`

Неизменяемые объекты являются **hashable**, то есть могут являться, например, ключами словаря.

Создание объекта происходит в два этапа:

- выделение области под объект (`__new__`)
- инициализация объекта (`__init__`)

Сама по себе переменная никогда не хранит сам объект, всегда хранится ссылка на него.
Почти каждый объект имеет атрибут `__dict__`, который содержит все атрибут данного объекта. 

<a id="markdown-2---функции-аргументы-функции" name="2---функции-аргументы-функции"></a>
# 2 - Функции, аргументы функции
Функции в Питоне тоже являются объектами, у которых определен метод `__call__`, который вызывается при написании круглых скобок. Функции вегда что-то возвращает. Даже если не указан `return` в коде (в этом случае возвращается None). 
Функция - **callable** объект

Типы аргументов:

- позиционные (определяются по их позиции в скобках)
- именные (определяются по имени аргумента)

Естественно, их можно комбинировать.

Дана функция
```python
def foo(a, b, c):
	pass
```

Ошибки:

- `foo(1, a=3, b=2)` - параметр `а` определяется несколько раз
- `foo(b=3, a=2, 2)` - позиционные аргументы должны идти всегда перед именными


___
## Распаковка
Пусть
```python
a = [1, 2, 3]
a1 = [2, 3]
d = {'c' : 3, 'b' : 12, 'a' : 1}
d1 = {'a':1, 'b':2}
```

`f(*a)` - позиционная распаковка из списка
`f(**d)` - именная распаковка из словаря

Распаковку можно комбинировать с другими параметрами:

* `f(1, *a1)`
* `f(c=1, **d1)` 

Частые ошибки:

* `f(*a1, b=2)` - `b` определено несколько раза
* `f(**d, 1)` - нельзя ставить позиционный аргумент после именной распаковки
* `f(**{a:1}, [2, 3])` - нельзя делать именную распаковку перед позиционной

## Упаковка
Упаковать аргументы функции обратно в список
```python
def foo(*args):
    pass 
```

Упаковать аргументы функции обратно в словарь
```python
def foo(**args):
	pass
```
Можно смешивать способы
```python
def foo(*args, c=10):
	pass

def bar(*args, **kwargs):
	pass
```
Ошибки:
```python
def f(**args, c)
```
```python
def f(**args, c=10)
```
**После именной упаковки ничего не должно идти!**

___
Можно прописать значения по умолчанию для параметров функции. 
```python
def g(a, b=2, c=3):
	pass

```
Ошибкой будет являться следующий код (так как недефолтный аргумент идет после дефолтного)
```python
def f(a, b=2, c):
	pass
``` 

## Анонимные функции

```python
f = lambda x: x + 1
```
## Замыкание
**Замыкание** - это процедура вместе с привязанной к ней совокупностью данных (в противовес объектам в объектном программировании, как: "данные вместе с привязанным к ним совокупностью процедур" ).

Смысл замыкания состоит в том, что определение функции "замораживает" окружающий её контекст на момент определения.
```python
n = 10
def foo(a=n):
	print(a)

foo() # 10
n = 2
foo() # 10
```

С лямбдами это работает совершенно по другому
```python
n = 10
foo = lambda x: n * x
foo(2) # 20
n = 2
foo(2) # 4
```

<a id="markdown-3---базовые-структуры-данных-tuple-list-set-frozenset-dict" name="3---базовые-структуры-данных-tuple-list-set-frozenset-dict"></a>
# 3 - Базовые структуры данных: tuple, list, set, frozenset, dict
Для типов, которые содержат некую последовательность объектов, в питоне поддерживаются следующие операции:

- `x in s`
- `x not in s`
- `s[i]`
- `s[i:j]`
- `s[i:j:k]`
- `s + t`
- `s * n`,  `n * s`
- `len(s)`
- `max(s)`, `min(s)`
- `.index(x, [start [, end]])` - возвращает положение первого элемента со значением x
- `.count(x)` - возвращает количество элементов со значением x

Последовательности одного и того же типа также поддерживают операторы сравнения (сравниваются лексиграфически)

**Imutable** типы  дополнительно подерживают `hash()`

**Mutable** дополнительно поддерживают:

- `s[i] = val`
- `s[i:j] = val`
- `s[i:j:k] = val`
- `del s[i:j]` что равностильно `s[i:j] = []`
- `s.append(x)`
- `s.clear()`
- `s.copy()` - возвращает shallow copy
- `s.extend(t)` что равносильно `s += t`
- `s *= n`
- `s.insert(i, x)`
- `s.pop([index])`
- `s.remove(x)` - убирает первое вхождение элемента (или кидает `ValueError` при отсутствии)
- `s.reverse()`

## List (iterable, mutable)
Способы задачи:
```python
    l1 = [1, 2]
    l2 = list()
    l3 = list(range(10))
```
**List comprehension** 
```python
[x**2 for x in range(10)]
[(x,y) for x in [1,2,3] for y in [3,1,4] if x != y]
```
Уникальные методы:
- `.sort([key=None, reverse=None])` - где, `key` это функция, которая выбирает элемент для сравнения

## Tuple (iterable, immutable, hashable)
Меньший размер по сравнению со спиком.
Способы задачи:
```python
t1 = tuple()
t2 = tuple([1, 2, 3])
t3 = 1, 2, 3
t4 = 's',
```
Прикольный синтаксис: `a,b = b,a`

## Dict (iterable(ключи), mutable)
Способы задачи:
```python
d1 = {}
d2 = dict.fromkeys(['a', 'b'], 1)  # {'a' : 1, 'b' : 1}
d3 = dict('one'=1, 'two'=2)
```
**Dictionary comprehension**
```python
d3 = {a: a ** 2 for a in range(10)}
```
Уникальные методы:
- `.get(key[, default])`
- `.items()` - ключ-значение
- `.keys()`
- `.pop(key[, default])`
- `.popitem()` - удаляет и возвращает пару. Если словарь пуст, бросает исключение `KeyError`.
- `.setdefault(key[, default])` - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ с значением default (по умолчанию None).
- `.update([other])` - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются.
- `.values()`

## Set (iterable, mutable)
Способы задачи:
```python
s1 = set()
s2 = set({'b' : 2, 'a' : 1})  # {'b', 'a'}
s3 = {1, 2, 3)
```
Может содержать только hashable объекты

Уникальные методы:
* `s <= t` - s подмножество t
* `s >= t` - t подмножество s
* `s | t` - объединение
* `s & t` - пересичение
* `s - t` - разность
* `s ^ t` - симметричная разность
* `.add(x)` - добавляет элемент к множеству.
* `.discard(x)` - удалить элемент если есть
* `.isdisjoint(x)` - истина если x и мн-во не имеют общих элементов
* `.issubset(s)` - ялвяется ли под-вом x
* `.issuperset()`
* `.pop()` - возращает и удаляет случайный элемент из мн-ва
* `.remove(x)` - удалить элемент из мн-ва (если нет такого эдемента, то KeyError)
* `.update(x)` - добавляет любой **iterable** объект.

## Frozenset (iterable, immutable)
Способы задачи эквивалентны `set`. Может содержать только hashable объекты

Уникальные методы
* поддерживает все методы множества, которые не меняют его

Можно проводить все алгебраические операции как со множествами:
* `frozenset` и `set` -> `set`
* `frozenset` и `frozenset` -> `frozenset`


<a id="markdown-4---строки-bytes-bytearray-str-кодировки" name="4---строки-bytes-bytearray-str-кодировки"></a>
# 4 - Строки: bytes, bytearray, str. Кодировки
`bytes.encode() -> str`

`str.decode() -> bytes`


## Str (iterable, immutable, hashable)

Содержит упорядоченную последовательность символов, каждый из которых по отдельности тоже строка. Может использоваться slice.
Сырые строки(`r'sample'`) - подавляют экранирование.

 * `.find(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или -1
 * `.rfind(str, [start],[end])` - поиск подстроки в строке. Возвращает номер последнего вхождения или -1
 * `.index(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или бросает ValueError
 * `.rindex(str, [start],[end]) `- поиск подстроки в строке. Возвращает номер последнего вхождения или бросает ValueError
 * `.isdigit()` - только цифры
 * `.isalpha()` - только буквы
 * `.isalnum()` - только цифры + буквы
 * `.islower()` - нижний регистр
 * `.isupper()` - верхний регистр
 * `.isspace()` - пробельные символы
 * `.istitle()` - с заглавной буквы
 * `.upper()`
 * `.lower()`
 * `.capitalize()`
 * `.swapcase()`
 * `.title()`
 * `.expandtabs()` - все `\t` в пробелы
 * `.startswith(str)`
 * `.endswith(str)`
 * `.count(sub[, start[, end]])` - выводит кол-во вхождений построки в строку. Учитываются только не перекрывающиеся вхождения
 * `.replace(old, new[, count])` - замена старой подстроки на новую `count` кол-во раз. Возвращает копию!
 * `.split(sep=None, maxsplit=-1)` - разбиение строки по разделителю (разделитель может быть строкой)
 * `.join(iterable)`
 * `.lstrip()`
 * `.strp()`
 * `.rstrip()`

`ord`; `chr`

* `.zfill(width)` - дописывает в начало строки 0, чтобы длина строки достикла `width`. Если на первом месте стоит +/-, то нули дописываются посл этого знака.

`.encode(encoding='urf-8', errors='strict')`
`.format(*args, **kwargs)`

## Bytes (iterable, immutable, hashable)

Элементы - байты, s[i] - выводит код ascii сивмвола. Является последовательностью чисел в диапазоне `[0..255]`

Для того, чтобы задать байтовую строку используется следующие правило:
* `[0..127]` показываются как литералы из ASCII таблицы. Все, кроме нечитаемых
* `[128..255]` показывается как escape-последовательность
	* `\x.. - hex[0..F]`
	* `\... - oct [0..7])`

Способы задачи:
```python
b1 = bytes([1, 2, 90, 255])
b2 = b'\xff\xf9\567'
```
Если допущена ошибка в escape-последовательности при задаче hex, то `ValueError`; в oct - просто игнорируется

## Bytearray (iterable, mutable)
Массив байт. Отличается от bytes только изменяемостью. Создаются только через конструктор

Методы соответствуют методам у строк + некоторые методы из списка. Единственный уникальный метод: `.decode(encoding='urf-8', errors='strict')`


<a id="markdown-5---классы-методы-__new__-__init__-переопределение-арифметических-операций-над-объектами" name="5---классы-методы-__new__-__init__-переопределение-арифметических-операций-над-объектами"></a>
# 5 - Классы. Методы `__new__`, `__init__`. Переопределение арифметических операций над объектами

Класс - это такой же объект как и все в питоне. У класса есть атрибуты. (которые хранятся у него в `__dict__`). Функцию, которая является атрибутом класса, принято называть **методом**. Они делятся на bound (в качестве первого параметра передается экземпляр класса) и unbound (ничего не передается)

```python
class A:
    def func(self):
        pass
A.a  # unbound method
A().a  # bound method
```

Инстанцирование обычного объекта происходит в 2 этапа:
1. создание - выполняется метод `__new__`
2. инициализация - выполняется `__init__`

```python
def __new__(cls): 
	...

def __init__(self):
	...
```
Если `__new__`, `__init__` - не определены, они ищутся у базовых(родительских) классов (по алгоритму поиска атрибутов у классов). Обычно ищется в `object.__dict__`

Рассмотрим на примере синглтона:
```python
class C:
   _instance = None
   
   def __new__(cls):
       if not cls._instance:
           cls._instance = super(C, cls).__new__(cls)
       return cls._instance
```


> `__new__` is the first step of instance creation. It's called first, and is responsible for returning a new instance of your class. In contrast, `__init__` doesn't return anything; it's only responsible for initializing the instance after it's been created. In general, you shouldn't need to override `__new__` unless you're subclassing an immutable type like `str`, `int`, `unicode` or `tuple`.


Также можно переопределять арифметические операции у экземплярами класса:
- `__lt__`
- `__le__`
- `__eq__`
- `__ne__`
- `__gt__`
- `__ge__`
- `__bool__` - `bool(a)`
- `__add__`
- `__sub__`
- `__mul__`
- `__truediv__` - `a/b`
- `__floordiv__` - `a//b`
- `__mod__`
- `__pow__`
- `__len__` - `len(a)`

<a id="markdown-6---итератор-устройство-цикла-for" name="6---итератор-устройство-цикла-for"></a>
# 6 - Итератор. Устройство цикла for
Итератор - это некий вспомогательный объект, который позволяется перечислять элементы контейнера (итерирование). Чтобы контейнер поддерживал итерацию, необходимо чтобы:

1. Контейнер определял метод `__iter__` , который возвращает итератор контейнера. Можно обратиться по встроенному методу `iter()`
2. У возвращаемого итератора был определен метод `__next__`, который возвращает следующий элемент контейнера. Можно обратиться по встроенному методу `next()`


```python
class MyClass:
	def __init__(self, *values):
	    if not values:
	        raise ValueError
	    self.values = values
	    self._current_id = 0

	def __iter__(self):
	    return self  # в данном случае сам контейнер является итератором

	def __next__(self):
	    if self._current_id >= len(self.values):
	        raise StopIteration
	    val = self.values[self._current_id]
	    self._current_id += 1
	    return val
```
## Устройство цикла for
```python
for i in [1, 2, 3]:
    print(i)
```
Данный цикл разварачивается в следующий код
```python
product = 1
i = iter([1, 2, 3])
while True:
    try:
        print(next(i))
    except StopIteration:
        print('The end is reached!')
```
<a id="markdown-7---генераторы-генераторные-выражения" name="7---генераторы-генераторные-выражения"></a>
# 7 - Генераторы. Генераторные выражения
Генератор (по утиной типизации) - это любой объект, у которого определены следующие методы:

1. `__iter__`
2. `__next__`
3. `send`
4. `throw`
5. `class`

Из этого уже следует, что генератор является итератором.

## Средства для создания генераторов
### Генераторные функции
```python
def _range(start, end, step=1):
	count = start
	while count < end:
	    yield count
		count += step

g = _range(1, 3)  # g - генератор
print(list(g))
```
  
Важно понимать что когда функция завершает исполнение кода (либо сама, либо через `return`), то автоматически генерируется исключение `StopIteration`.
### Генераторные выражения
Очень похоже на list-comprehension.
```python
g = (x ** 2 for x in range(1, 10) if x % 2 == 0)
```
Естественно, в этой строчке цикл не выполняется, только возвращается генератор.
 ___
 Метод `next()`, по сути, исполняет функцию пока не встретит `yield`. Встретив эту директиву, он возвращает значение и выходит из функции. Следующий `next()` начинает с прежнего места выхода.
 
 Чтобы получить первое значение из генератора необходимо использовать `next()` или `send(None)`. Также, важно понимать, что генераторы нельзя использовать повторно.
 
`send(value)`
>Resumes the execution and "sends" a value into the generator function. The value argument becomes the result of the current yield expression. The `send()` method returns the next value yielded by the generator, or raises `StopIteration` if the generator exits without yielding another value. When `send()` is called to start the generator, it must be called with `None` as the argument, because there is no yield expression that could receive the value.

```python
import random

def cf():
	while True:
		val = yield
		print(val)

def df(gen):
	while True:
		gen.send(random.randint(1, 10))
		yield


c = cf()
c.send(None)  # нельзя посылать сразу не None значение
d = df(c)
for i in range(0, 10):
	next(d)
```  

Метод `send()` кардинально отличает генераторы от итераторов

Еще пример
```python
def _range(start, stop, step=1):
    c = start
    while c < stop:
        reset = yield c  # сначала выполнится yield, затем в следующем next/send в reset запишется то, что было передано (если next - то None)
        if reset is not None:
            c = reset - step
        c += step


r = _range(0, 10, 2)
next(r) # 0
next(r) # 2
next(r) # 4
r.send(-2) # -2
next(r) # 0
next(r) # 2
```
*Важно понимать, что `next` и `send` работают до первого `yield`*
<a id="markdown-8---генераторные-функции" name="8---генераторные-функции"></a>
# 8 - Генераторные функции
Генераторные функции - все функции, в которых используется конструкция  `yield` или `yield from`.
```python
def _range(start, stop, step=1):
    c = start
    while c < stop:
	    reset = yield c
	    if reset is not None:
		    c = reset - step
	    c += step
		
def two_ranges(start, end):
    yield from _range(start, end)
    yield from _range(start, end)


g = two_ranges(0, 3)
print(next(g)) # 0
print(next(g)) # 1
print(g.send(-1)) # -1
print(next(g)) # 0
print(next(g)) # 1
print(next(g)) # 2
print(next(g)) # 0
print(next(g)) # 1
print(next(g)) # 2
```
Можно бы было сделать два цикла `for` внутри `two_ranges`, но тогда бы не работал метод `send`. 

`yield from` помимо функциональности `for` и `yield` позволяет организовать связь между внешним генератором и внутренним. 

Метод `throw` позволяет пробрасывать исключение внутри генератора
```python
def foo():
    while True:
	    try:
	        s = yield
	        print(s)
	    except:
	        print('Exception occurred')


f = foo()
f.send('hello')  # hello
f.throw(Exception('Sample exception'))  # Exception occurred
```

<a id="markdown-9---list-set-dict-comprehensions" name="9---list-set-dict-comprehensions"></a>
# 9 - list, set, dict comprehensions

В отличии от генераторных выражений (которые очень похожи) возвращают список, множество, словарь соответственно. То есть вычисляются (исполняется цикл) сразу же при определении.

```python
l = [x * x for  x in range(10) if x % 2 == 0]
s = {x * x for  x in range(10) if x % 2 == 0}
d = {x: x * x for  x in range(10) if x % 2 == 0}
```

<a id="markdown-10---функции-как-объекты-декораторы" name="10---функции-как-объекты-декораторы"></a>
# 10 - Функции как объекты. Декораторы


Функции - тоже объекты (как и все в Python). Функции можно передавать в качестве параметра, присваивать переменным и т.п. Также можно определять функции внутри других функций (дескрипторы)

* `filter(func, iterable)`
* `map(func, iterable)`

**Lambda-функции**
```python
f = lambda (x, y): x + y
```
Полезные атрибуты функций:
* `__name__` - имя функций. У анонимных: `<lambda>`
* `__doc__` - строка документации, по дефолту пустая
* `__module__` - название модуля, в котором функция была определена. `"__main__"` - если была определена здесь же

Функции объявляют, чтобы:
1. избежать дублирования кода
2. выделить логические блоки кода для повторного использования
3. улучшить читаемость кода
4. повысить управляемость кода (удобно для нахождения ошибок)


**Декораторы** - это своеобразные "обертки" над другими функциями, которые могут изменять поведения этих других функций без изменения их кода

> Декораторы - это функции, которые на вход принимают функцию (func1) и возвращают функцию (func2), которая изменяет работу func1

```python
def logging(func):
    def local_func(*args, **kwargs):
	    print(func.__name__)
	    return func(*args, **kwargs)
	local_func.__name__ = func.__name__
	local_func.__doc__= func.__doc__
	return local_func

@logging
def boo(a, b, c=1):
    print(a + b + c)
```

В данном примере `@logging` эквивалентно `boo = logging(boo)`

```python
def dec(a):
    def loc_decorator(func):
        def loc_func(*args, **kwargs):
            print(args, kwargs)
            print(a)
            return func(*args, **kwargs)
        return loc_func
    return loc_decorator

@dec('lol')
def boo(a, b):
    print('boo')
```
Или `boo = dec('lol')(boo)`

**Порядок следования декораторов важен**

```python
@dec_2
@dec_1
def bar():
    pass

@dec_1
@dec_2
def foo():
    pass
```

Часто вместе с функцией требуется протащить ее имя и докстринг. В этом нам поможет `functools.wraps`
```python
import functools

def logging(func):
    @functools.wraps(func)
    def local_func(*args, **kwargs):
        print(func.__name__)
        return func(*args, **kwargs)
    return local_func

@logging
def bar(text):
    print(text)
```
На практике очень часто используются декораторы:
* `@property` - для создания property у класса
* `@staticmethod` - делает метод статическим
* `@classmethod`

*P.S. На самом деле `@staticmethod` и `@classmethod` - это комбинация использования декораторов и дескрипторов*

Использование свойств
```python
class A:
    def __init__(self, r):
		self._r = r
        
    @propety
    def r(self):
		return self._r
    
    @r.setter
    def r(self, r):
		if r < 0:
		    raise ValueError
        else:
	        self._r = r
```
Примерная реализация `@staticmethod`

```python
class StaticMethod:  # так называемый протокол дескриптора     
    def __init__(self, func):
        self.__func__ = func

    def __get__(self, obj, type=None):
            return self.__func__

def staticmethod(func):  # сам декоратор
    return StaticMethod(func)

class A:
    @staticmethod
    def foo(a):
        print(a)

# То есть в функцию, вместо self, искусственно подбрасывается экземпляр класса StaticMethod
A().a(1)  # 1
A.a(1)  # 1
```
`functools` - библиотека с декораторами
<a id="markdown-11---наследование-в-классах" name="11---наследование-в-классах"></a>
# 11 - Наследование в классах

* `__class__`
	* для экземпляров класса - это сам класс
	* для класса - это тип

* `__bases__` - у класса, все классы от которых он наследуется
* `__subclasses__` - хранит классы, которые наследовались от данного класса

___
* `isinstance(a, A)` - `а` это объект класса `A` (работаетс `__class__`)
* `issubclass(A, C)` - `A` это подкласс `C` (работает с `__bases__`)

`type(x) ==  x.__class__`

Алгоритм поиска атрибутов у экземпляра класса:
1. Поиск атрибута в `__dict__` экземпляра класса
2. Поиск  в `__dict__` у класса
3. Поиск в `__dict__`  у потомков класса

`super()` - обращается к классу родителю
<a id="markdown-12---обработка-исключений" name="12---обработка-исключений"></a>
# 12 - Обработка исключений

## Обработка исключения
```python
try1_stmt ::=
    try : suite
    (except : [expression [as target]] : suite)+
    [else : suite]  # если не было исключений
    [finally : suite]  # выполняется всегда в конце
try2_stmt ::=
    try : suite
    finally : suite
```
## Генерация исключения
```python
raise_stmt ::= raise [expression [from expression]]
```
Можно кидать исключения в обработчике
```python
try:
	raise Exception
except:
	raise ValueError
```
```python
Exception: <...>
During handling of the above exception, another exception occurred:
ValueError: <...>
```

Как видно из синтаксиса, можно не указывать исключение: тогда будет прошено предыдущие исключение (если такого не было, то `RuntimeError`
```python
try:
    raise ValueError
except ValueError as e:
	<...>
    raise 
```
```python
ValueError: <...>
```

```python
except ValueError as e:
    print('except ValueEror')
except:
    print('except')
    # ветка, которая охватит все оставшиеся исключения
else:
    print('else')
finally:
    print('finally')
```
При попытке вызвать исключение в обработчике, оно будет вызвано **после** исполнения блока `finally`


`sys.exc_info()` - хранит информацию об последнем вызванном исключении, пойманным блоком except. Возвращает `(type, value, traceback)`

`traceback.print_exception((type, value, tb))` - печатает инфу по исключению

`tracebcak.print_exc()` то же самое, что `traceback.print_exception(sys.exc_info())`
```python
def f1():
    f2()

def f2():
    f3()

def f3():
    raise ValueError
```
Исключение всплывает вверх по стеку вызовов.

В обрабатывающих ветках можно указывать большо одного исключения
```python
try:
    pass
except (ValueError, MyError, RuntimeError):
    pass
```

Блок `finally` выполняется всегда, когда интерпретатор покидает оператор `try`, независимо — были исключения или нет. Если в блоке `try` появилось исключение, которое не было обработано в блоке `except` (или появилось в самих блоках `except` или `else`) — оно порождается заново после выполнения блока `finally`.

Полезные атрибуты класса `Exception`:
* `__cause__` - что послужило исключением
* `__context__` - контекст из которого было вызвано исключение
* `__supress_context__` - флаг подавления вывода `__context__`
* `args` - аргументы

___
Конструкция
```python
raise <exception1> from <exception2>
```
позволяет пояснять программисту, что послужило причиной вызова первого исключения. Для этого меняется значение атрибута `__cause__`.
При этом пишется следующее
```python
<exception1_info>: 

The above exception was the direct cause of the following exception:

<exception2_info>
```

Если мы бросили исключение **в обработчике исключений**, то устанавливается поле `__context__`. Пишется слудующее
```python
<exception1_info>

During handling of the above exception, another exception occurred:

<exception2_info>
```

Если совместить 2 случая выше, то будет установлено только поле `__cause__` (влажок `__supress_context__` будет `True`). Поэтому чтобы избежать лишней инфы при кидании исключения в обработчике используют следующую конструкцию:
```python
try:
	...
except:
	raise <exception> from None
```


<a id="markdown-13---создание-собственных-классов-исключений-иерархии-исключений" name="13---создание-собственных-классов-исключений-иерархии-исключений"></a>
# 13 - Создание собственных классов исключений. Иерархии исключений.

Создадим свое исключение
```python
class MyError(Exception):
    def __init__(self, message):
            self.message = message
        
    def __str__(self):
            return self.message

raise MyError('Lol')
```

<a id="markdown-14---устройство-with" name="14---устройство-with"></a>
# 14 - Устройство with
```python
with_stmt ::= with with_item (, with_item)* : suite,
где
with_item ::= expression [as target]
```

**Менеджер контекста** - объект, поддерживающий 2 метода:
* `__enter__()` - возвращает объект, результат операции
* `__exit__(exc_type, exc_value, exc_traceback)` - обрабатывает исключение. При успехе: `True`, иначе `False`

```python
mgr = (EXPR)
exit = mgr.__exit__
value = mgr.__enter__()
no_exc = True

try:
    try:
        VAR = value
        BLOCK
    except:
        no_exc = False
        if not exit(*sys.exc_info()):
            raise
finally:
    if no_exc:
        exit(None, None, None)
```
Равносильно следующей конструкции
```python
with EXPR as VAR:
    BLOCK
```
Следующие конструкции эквиваленты
```python
with A() as a:
    with B() as b:
        suite

with A() as a, B() as b:
    suite
```


<a id="markdown-15---модули-пакеты-import-и-его-варианты" name="15---модули-пакеты-import-и-его-варианты"></a>
# 15 - Модули, пакеты, import и его варианты

## Модули

Модуль - просто файл с расширением `.py`. Из себя он представляет объект с определенными аттрибутами к которым можно обращаться. Импортируется модуль через `import`, `as` - просто переименовывает ссылку на этот объект для того, чтобы можно было удобнее к нему обращатся (имя модуля не меняется). Граница между модулем и объектом тонка.

`sys.path` - содержит пути, в которых питон ищет модули

Интересные аттрибуты модулей:
* `__cached__` - скомпилированный байт-код версии исходного файла
* `__doc__` - докстринг как в функции
* `__file__` - абсолютный путь до файла
* `__name__` - имя модуля (файла). При запуске `"__main__"`
* `__parent__` - имя пакета, в котором находится данным модуль

___
```python
from <module> import <something>
```
 Ипортирует атрибуты из модуля в текущую область видимость. Сам модуль не импортируется

```python
from <module> import *
```
Импортируем из модуля все атрибуты, кроме скрытых (тех, что начинаются с `_`). Для изменения повидения данной операции юзай атрибут `__all__` (контролирует только `*`)

Процесс импортирования модуля:
1. найти, в каком файле расположен данный модуль.
	* Питон смотрит в кэш, не был ли модуль импортирован ранее
	* поискать встроенный модуль
	* смотрит в текущей папке
	* обращается к некоторому списку путей из `sys.path`, `$PYTHONPATH`
2. создать соответствующие имена переменных в текущем пространстве имен.

## Пакеты

Пакет это любая папка с модулями (можно и без) + `__init__.py`
```
test
├── bar.py
├── foo.py
├── __init__.py
└── main.py
```

```python
import test
```
Тут на самом деле импортируется (и запускаетя) модуль `__init__.py`
Остальные пакеты надо импортировать явно

```python
import test.foo
```
Ипортирует модуль `foo.py` а также `__init__.py` (если он еще не был импортирован)

Два вида импортирования:
* Абсолютный импорт - полность прописываем путь до **пакета**
* Относительный ипорт  - можно использовать `.`/`..` для указания путя **пакета**. `from .package1.package2.test import foo`

**Опять же, чтобы юзать относительный испорт необходимо, чтобы директория являлась пакетом**

Чтобы пакет был исполняемым надо добавить `__main__.py`

>Пакеты содержат в себе наборы модулей. Отличительная черта пакета - это некоторая директория, которая содержит файл `__init__.py`. В этом файле можно описать код, который будет инициализировать пакет. Инициализационный код выполняется только один раз при импортировании пакета (даже если из него импортируются разные модули).
 
Чтобы импортировать из одного модуля пакета другой модуль этого же пакета, надо указать не только имя импортируемого модуля, но и сначала имя самого пакета, так как поиск ведётся в текущей директории, а не в директории пакета.

Одни пакеты можно вкладывать в другие. 

Так же полезен модуль `importlib`

<a id="markdown-16---пространство-имен-область-видимости" name="16---пространство-имен-область-видимости"></a>
# 16 - Пространство имен, область видимости
**Пространство имен** - соответствие имени переменной и ссылки на объект, которая она хранит.

**Область видимости** - те участки кода, откуда будет доступен данный объект.

Пространства имён содержит:
1. пространство локальных имен
2. пространство имен окружающих функций, начиная от самой ближайшей по вложенности
3. пространство глобальных имен
4. пространство встроенных имен (например, built-in functions)

```python
c = 10
def f():
    global c # после этого под с будет пониматься глобальная переменная
    c = 11
    print(c)
    
print(c)  # 10
f()  # 11
print(c)  # 11
```
По завершению работы функции её пространство имен удаляется
```python
a = 1

def f():
    a = 2    
    def g():
		print(a)  # 2 
        nonlocal a
        a = 3
        print(a)  # 3
    g()
    print(a)  # 3

f()
print(a)  # 1
```
`nonlocal` смотрит на уровень вложенности выше, но вылезает в пространство глобальных переменных (если некуда лезть, то `SyntaxError`)

Внутри if-ов и циклов не создается свое пространство имен

* `globals()` - словарь глобальных переменных
* `locals()` - словарь локальных переменных


<a id="markdown-17---метод-__del__-удаление-объектов-при-помощи-подсчета-ссылок" name="17---метод-__del__-удаление-объектов-при-помощи-подсчета-ссылок"></a>
# 17 - Метод `__del__`. Удаление объектов при помощи подсчета ссылок

Метод `__del__` предназначен для удаления объектов из памяти. Он вызывается, когда на объект никто не ссылается.

`sys.getrefcount(obj)` - метод, возвращающий кол-во ссылок на переданный объект + 1 (из-за внутренней реализации)

Счетчик ссылок и сборщик мусора работают сообща. Сборщик мусора доступен в модуле `gc`. 

Важно понимать, что оператор `del` не имеет никакого отношения непосредственно к объектам. Он всего лишь удаляет переменные из текущего пространства имен (то есть удаляет ссылку на объект)

```python
a = '123'
b = a
del a
print(b)  # 123
```
**Циклические ссылки**
```python
class Element:
    def __init__(self, data, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next
        
    def __del__(self):
        print('deleting', self.data)

head = Element(1)
tail = Element(2)
head.prev = tail
tail.next = head

del head
del tail
```
Ни один объект не будет забран сборщиком, так как оба объекта ссылаются друг на друга (как минимум есть по одной сслыке на каждый объект). Данные объекты будут удалены только по завершению работы скрипта.

**Слабые ссылки (weak reference)**

Отличаются от обычных ссылок тем, что не увеличивают счетчик ссылок объекта, на который ссылаются. Как следствие: не оказывает влияния на работу сборщика мусора. Можно использовать для избежания циклических ссылок.

Для создания ссылки на объект используй метод `weakref.ref(obj)`
```python
import weakref
import gc


class MyObject(object):
    def my_method(self):
        print('my_method was called!')

obj = MyObject()
r = weakref.ref(obj)

gc.collect()
assert r() is obj
# r() позволяет обратиться к объекту на который ссылается

obj = 1
gc.collect()
assert r() is None  # Объект был удален сборщиком мусора
```
<a id="markdown-18---работа-с-файлами" name="18---работа-с-файлами"></a>
# 18 - Работа с файлами
Методы:
* `open(file, mode='r', encoding=None)`

	mode:
	* `r` на чтение
	* `w` на запись (с начала файла)
	* `x` исключение, если файл уже в каталоге
	* `a` на запись (дописать в конец)
	* `b` байты
	* `t` символы

* `f.read([n])` - можно указать кол-во символ для считывания
* `f.seek(i)` - перейти к i-ому символу
* `f.close()`  - закрыть файл
* `f.write(data)` - записывает данные в файл, возвращает кол-во записанных файлов

<a id="markdown-19---создание-потоков-модуль-threading" name="19---создание-потоков-модуль-threading"></a>
# 19 - Создание потоков, модуль threading

Пример работа с тредами
```python
import threading
import time

def func():
    for _ in range(10):
        time.sleep(0.001) # уведичиваем вероятность то, что другой тред начнет свою работу
        print('hello from ', threading.current_thread().name)

for _ in range(10):
    t = threading.Thread(target=func)
    t.start()
```
Залочим переменную. Это необходимо, так как прибавление еденицы не атомарная операция.
```python
count = 0
lock = threading.Lock()

def inc():
    global count
    with lock:
        k = count
        time.sleep(0.001)
        count = k + 1

pool = []    
for _ in range(1000):
    t = threading.Thread(target=inc)
    t.start()
    pool.append(t)
for t in pool:
    t.join()  # ждем его завершения
print(count)
```
Deadlock
```python
lock1 = threading.Lock()
lock2 = threading.Lock()

def good():
    with lock1:
        time.sleep(1)
        with lock2:
            print('good')

def bad():
    with lock2:
	    with lock1:
	        print('bad')

threading.Thread(target=good).start()
threading.Thread(target=bad).start()
```


В мультипоточной программе доступ к объектам иногда нужно синхронизировать. С этой точки зрения все объекты (переменные) разделяются на:
 * Неизменяемые. Если объект никто не меняет, то синхронизация доступа ему не нужна. К сожалению, таких не очень много.
* Локальные. Если объект не виден остальным потокам, то доступ к нему синхронизировать тоже не требуется.
* Разделяемые и изменяемые. Необходима синхронизация.

`lock.acquire()` - захватить lock
`lock.release()` - отпустить lock

<a id="markdown-20---способы-создания-процессов" name="20---способы-создания-процессов"></a>
# 20 - Способы создания процессов

**Процесс** - уже самостоятельная единица ОС и может происходить ядерное распараллеливание. Процесс имеет как минимум 1 поток (главный). Процессы имеют разные области памяти. 

Для нормальной работы нужна синхронизация и взаимодействие между процессами. Взаимодействие может осуществляться с помощью `file`, `signals` (список сигналов - `kill -l`),  `pipe`, `socket`, `mmap`.

Способы создания новых процессов:

1. В Unix-подобных ОС используется `fork()` (`os.fork`). Данный способ достаточно быстрый. При вызове `fork()` у процесса возникает его идентичная копия. Возвращает `pid` процесса (для родительского - `pid` ребенка, а для дочернего - 0). По ним можно узнать в каком именно процессе мы сейчас находимся. Копирует все данные из одного процесса в другой. Могут возникнуть проблемы с процессобезопасностью.



2. `subprocess` - позволяет создать новый процесс и обмениваться с ним информацией по трубам, стандартным потокам ввода-вывода
	```python
	cmd = 'ping google.com'
	p = subprocess.Popen(cmd, shell = True) 
	```
3. `multiprocessing.Process(target=foo)` запуск нового процесса с исполняемой функцией
4. `concurent.futures` - модуль для удобной работы как с потоками, так и с процессами

